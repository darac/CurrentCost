#!/usr/bin/perl
# -*- perl -*-

=head1 NAME

=encoding utf8

currentcost - Munin plugin to monitor a CurrentCost energy monitor

=head1 APPLICABLE SYSTEMS

Any system connected to a CurrentCost monitor. These can be purchased from L<http://www.currentcost.com>.

=head1 CONFIGURATION

This plugin requires the following Perl modules. Either fetch them from CPAN or your distribution.

=over

=item *

XML::Simple

=item *

Device::SerialPort

=item *

JSON

=item *

Time::Local

=item *
Daemon::Daemonize

=back

This configuration section shows the defaults of the plugin:

    [currentcost]
    env.device          /dev/ttyUSB0
    env.baud            2400
    env.tick            6
    env.currency        £
    env.rate1           13.9
    env.rate1qty        900
    env.rate2           8.2
    env.nightrate       0
    env.nighthours      23:30-06:30
    env.standingcharge  0.0
    env.metertype       CC128

The configuration can be broken down into the following subsections:

=head2 DEVICE

=over

=item env.device

Specfies the device node where the CurrentCost monitor can be found. You may find it useful to use a udev rule to symlink this somewhere permanent (for example: C<SUBSYSTEM=="tty", SUBSYSTEMS=="usb", ATTRS{manufacturer}=="Prolific Technology Inc.", ATTRS{product}=="USB-Serial Controller", SYMLINK+="currentcost%n"> will allow you to specify /dev/currentcost0 here).

=item env.baud

Specifies the baud rate to use. CurrentCost devices may speak at 2400, 9600 or 57600 baud, depending on their age.

=item env.tick

How long, in seconds, to consider data valid for. CurrentCost monitors typically put out data every 6 or 10 seconds. This will influence the generation of your RRD (which is only done I<once>).

=back

=head2 COSTS

=over

=item env.currency

The currency symbol to use on the cost graph. CurrentCost typically uses "E<pound>" or "E<euro>", but you may find "$" more to your taste.

=item env.rate1

The primary rate in hundredths of a C<env.currency> per kWh. (i.e. pence/cents per kWh)

=item env.rate1qty

How many kWh per month are charged at C<env.rate1>. Some tariffs charge one rate for the first so many units and then another rate for the remainder. If you are charged a flat rate per unit, set this to 0.

=item env.rate2

The secondary rate in hundredths of a C<env.currency> per kWh. (i.e. pence/cents per kWh)

=item env.nightrate

The night rate in hundredths of a C<env.currency> per kWh. Some tariffs (such as Economy 7) charge differently during the night and typically require a meter capable of reading two rates. If you do not have such a tariff, set this to 0.

=item env.nighthours

The time period for which C<env.nightrate> applies. This should be of the form C<hh:mm-hh:mm> and should span midnight.

=item env.standingcharge

The standing charge in hundreths of a C<env.currency> per month. If you do not have a standing charge, set this to 0.

=item env.metertype

The model of the meter. Currently "CC02" and "CC128" are supported.

=back

=head1 MAGIC MARKERS

 #%# family=auto contrib
 #%# capabilities=multigraph

=head1 AUTHOR

Paul Saunders L<darac@darac.org.uk>

=cut

#vim: set autoindent expandtab tabstop=4 shiftwidth=4

use strict;
use warnings;
use utf8;
use Munin::Plugin;
use Fcntl qw(:flock SEEK_END SEEK_SET);

need_multigraph();

my $device_node = $ENV{device} || "/dev/ttyUSB0";
my $baud_rate   = $ENV{baud}   || "2400";           # or 9600 or 57600
my $tick_rate   = $ENV{tick}   || "6";

# Tick_Rate is how long to consider data valid for (in seconds)

# Costs
my $currency  = $ENV{currency}  || "£";      # £ or €
my $rate1     = $ENV{rate1}     || "13.9";    # in pence/cents
my $rate1qty  = $ENV{rate1qty}  || "900";     # in kWh, 0 to use fixed rate2
my $rate2     = $ENV{rate2}     || "8.2";     # in pence/cents
my $nightrate = $ENV{nightrate} || "0";       # 0 = disabled
my $nighthours = $ENV{nighthours} || "23:30-06:30";
my $standingcharge = $ENV{standingcharge} || "0.0";    # pence/cents per month

#my $metertype      = $ENV{metertype}      || "CC128";  # Should be able to auto-detect this based on msg/src
# TODO: What about Gas?

my $MUNIN_DEBUG = $ENV{MUNIN_DEBUG} || 0;

my @Required_Modules = qw(XML::Simple Device::SerialPort JSON Time::Local Proc::Daemon Log::Dispatch Log::Dispatch::File Date::Format File::Spec);

my $ret;
for my $module (@Required_Modules){
    if ( !eval "require $module;" ) {
        $ret .= "Could not load $module; ";
    }
}

if ( defined $ARGV[0] and $ARGV[0] eq 'autoconf' ) {

    # Shouldn't autoconfigure as there's no reliable way to detect
    # serial devices.
    print "no";
    if ($ret) {
        print " ($ret)\n";
    }
    else {
        print " (can't auto-detect serial devices)\n";
    }
    exit 0;
}

## Configuration. You shouldn't need to change these
our @lastread;
our $daemon_pidfile = "$Munin::Plugin::pluginstatedir/munin.currentcost.pidfile";
our $value_spoolfile =
  "$Munin::Plugin::pluginstatedir/munin.currentcost.value-spool";
our $config_spoolfile =
  "$Munin::Plugin::pluginstatedir/munin.currentcost.config-spool";
our $cumulative_spoolfile =
  "$Munin::Plugin::pluginstatedir/munin.currentcost.cumulative-spool";
our $LOG_FILE = '/var/log/currentcost.log';
our $ME = $0; $ME =~ s|.*/||;

###### LOGGING ######
my $log = new Log::Dispatch(
    callbacks => sub { my %h=@_; return Date::Format::time2str('%B %e %T', time)." $0\[$$]: $h{message}\n";}
);
$log->add(Log::Dispatch::File->new( name      => 'file1',
                                    min_level => $MUNIN_DEBUG ? 'debug' : 'warning',
                                    mode      => 'append',
                                    filename  => $LOG_FILE,));
sub dienice($) {
    my ($package, $filename, $line) = caller;
    $log->critical("$_[0] at line $line in $filename");
    die $_[0];
}

###### DAEMON ######
sub run_daemon {

    $log->warning("Daemon forked");

#    # Start by opening the serial port
#    my $tty = new Device::SerialPort($device_node)
#      || die "Can't open $device_node: $!";
#    $tty->baudrate($baud_rate) || die "Can't set serial baud rate";
#    $tty->parity("none")       || die "Can't set serial parity";
#    $tty->databits(8)          || die "Can't set serial databits";
#    $tty->handshake("none")    || die "Can't set serial handshake";
#    $tty->read_char_time(100);
#    $tty->read_const_time(100);
#    $tty->error_msg(1);
#    $tty->user_msg(1);
#    $tty->write_settings || die "Can't set serial parameters";
    open (my $tty, '<', $device_node) || dienice "Can't open $device_node: $!";

    my $daemonstarttime = time();
    my $ttybuffer       = "";

    # We should be ready to talk to the CC now
    while (1) {
        if ( time() >= $daemonstarttime + 30 and $MUNIN_DEBUG ) {
            $log->warning (
              ( time() - $daemonstarttime )
              . " seconds have elapsed, stopping daemon");
            return;
        }
#        my $char = $tty->lookfor();
	my $char = <$tty>;
        if ($char) {
            $_ .= $char;
        }
        else {
            sleep(1);
            next;
        }
        $log->debug ("Read from device: $_") if $MUNIN_DEBUG;
        if (m{(<msg>.*?</msg>)}) {
            my $xmlref = XML::Simple::XMLin( $1, KeepRoot => 1 );
            s/$1//;    # Remove the message from the buffer

            my $CC_Personality = $xmlref->{msg}->{src};

            my $valuehash;

            $valuehash->{timestamp} = time();

            # Note that we COULD take a timestamp from the CC,
            # but as it only supplies HH:MM:SS, determining if
            # the timestamp is from a different day (i.e. around midnigh)
            # or if the clock is just wrong is difficult.
            #
            #  Patches welcome
            #

            if ( $CC_Personality =~ /CC128/ ) {
                $valuehash->{sensor} = $xmlref->{msg}->{sensor};
            }
            elsif ( $CC_Personality->{name} =~ /CC02/ ) {
                $valuehash->{sensor} = 0;
            }
            if ( !defined $valuehash->{sensor} ) {
                $log->info( "Not handling historical data") if $MUNIN_DEBUG;
                next;
            }
            $log->debug ("Data for Sensor $valuehash->{sensor} follows:")
              if $MUNIN_DEBUG;

            $valuehash->{temperature} = $xmlref->{msg}->{tmpr};

            foreach my $key ( keys %{ $xmlref->{msg} } ) {
                if ( $key =~ /^ch(\d+)$/ ) {
                    my $channel = $1;
                    my $unit = ( keys %{ $xmlref->{msg}->{"ch$channel"} } )[0];
                    my $val  = $xmlref->{msg}->{"ch$channel"}->{$unit};
                    $log->debug("#   Channel $channel, Unit $unit, Value $val")
                      if $MUNIN_DEBUG;
                    $valuehash->{$channel} = {
                        unit  => $unit,
                        value => $val,
                    };
                }
            }

            # Data read and parsed. Time to save it to the spoolfile
            open( my $spoolfile, '>>', "$value_spoolfile" )
              || dienice "Can't open spoolfile ($value_spoolfile): $!";

            # Lock the value spoolfile
            flock( $spoolfile, LOCK_EX ) or dienice "Can't lock spoolfile: $!";
            seek( $spoolfile, 0, SEEK_END )
              or dienice "Can't seek in spoolfile: $!";

            # Spoolfile locked (and ready to append at end)

            print $spoolfile JSON->new->utf8->encode($valuehash) . "\n";

            flock( $spoolfile, LOCK_UN ) or dienice "Can't unlock spoolfile: $!";

            close($spoolfile);

            # Also save list of sensors/channels/units to config spool
            my $tempconfig;
            eval {
                open( $spoolfile, '<', "$config_spoolfile" )
                  || dienice "Can't open spoolfile ($config_spoolfile): $!";

                flock( $spoolfile, LOCK_EX ) or dienice "Can't lock spoolfile: $!";
                seek( $spoolfile, 0, SEEK_SET )
                  or dienice "Can't seek in spoolfile: $!";

                $tempconfig = JSON->new->utf8->decode(
                    do { local $/ = <$spoolfile> }
                );
                flock( $spoolfile, LOCK_UN )
                  or dienice "Can't unlock spoolfile: $!";
                close($spoolfile);
                1;
            } or do {
                print $@;
            };

            open( $spoolfile, '>', "$config_spoolfile" )
              || dienice "Can't open spoolfile ($config_spoolfile): $!";
            flock( $spoolfile, LOCK_EX ) or dienice "Can't lock spoolfile: $!";
            seek( $spoolfile, 0, SEEK_SET );

            for my $channel ( keys %$valuehash ) {
                next unless $channel =~ /^\d+$/;
                $tempconfig->{ $valuehash->{sensor} }->{$channel} =
                  $valuehash->{$channel}->{unit};
            }
            truncate( $spoolfile, 0 );
            seek( $spoolfile, 0, SEEK_SET )
              or dienice "Can't seek in spoolfile: $!";
            print $spoolfile JSON->new->utf8->encode($tempconfig);

            flock( $spoolfile, LOCK_UN ) or dienice "Can't unlock spoolfile: $!";

            close($spoolfile);

        }
        $_ = "";

        sleep 1;
    }
}

###### PLUGIN ######

sub is_night_rate {
    my $reftimeparam = $1 || time;
    my @reftime = localtime($reftimeparam);

    # Determine if we're on night rate
    return 0 if not $nightrate;
    my ( $nightstart, $nightstop ) = split /-/, $nighthours;
    my ( $start_h,    $start_m )   = split /:/, $nightstart;
    my ( $stop_h,     $stop_m )    = split /:/, $nightstop;
    my $start_time = $start_m + ( $start_h * 60 );
    my $stop_time  = $stop_m +  ( $stop_h * 60 );
    my $ref_time = $reftime[1] + ( $reftime[2] * 60 );

    if (   $ref_time >= $start_time
        or $ref_time <= $stop_time )
    {
        print "# Night rate is ACTIVE\n" if $MUNIN_DEBUG;
        return 1;
    }
    else {
        print "# Night rate is enabled, but NOT active\n" if $MUNIN_DEBUG;
        return 0;
    }
}

=head1 EXAMPLE INPUT

The device will periodically output a string of XML. The string will be all on one line, they are expanded here for clarity.

=head2 Classic format

Note: I can't find an official spec for this format so, for now, we're using the definitions supplied by L<http://cumbers.wordpress.com/2008/05/07/breakdown-of-currentcost-xml-output/>:

 <msg>
    <date>
        <dsb>00014</dsb>        Days since birth
        <hr>14</hr>             \
        <min>07</min>            | The Time
        <sec>07</sec>           /
    </date>
    <src>
        <name>CC02</name>       Name of this Device
        <id>03280</id>          Communication channel for device
        <type>1</type>          Harware version
        <sver>0.07</sver>       Software version
    </src>
    <ch1>
        <watts>00080</watts>    Value from the first channel
    </ch1>
    <ch2>
        <watts>00000</watts>    Value from the second channel
    </ch2>
    <ch3>
        <watts>00000</watts>    Value from the second channel
    </ch3>
    <tmpr>28.8</tmpr>           Current temperature (degrees celsius)
    <hist>
        <hrs>
            <h02>000.0</h02>    Total kWh used in 2 hour blocks
            <h04>000.1</h04> 
            <h06>000.1</h06> 
            <h08>000.0</h08> 
            <h10>000.0</h10> 
            <h12>000.0</h12> 
            <h14>000.0</h14> 
            <h16>000.1</h16> 
            <h18>000.1</h18> 
            <h20>000.1</h20> 
            <h22>000.1</h22> 
            <h24>000.0</h24> 
            <h26>000.0</h26> 
        </hrs>
        <days>
            <d01>0000</d01>     Total kWh used per day
            <d02>0000</d02> 
            <d03>0000</d03> 
            <d04>0000</d04> 
            <d05>0000</d05> 
            <d06>0000</d06> 
            <d07>0000</d07> 
            <d08>0000</d08> 
            <d09>0000</d09> 
            <d10>0000</d10> 
            <d11>0000</d11> 
            <d12>0000</d12> 
            <d13>0000</d13> 
            <d14>0000</d14> 
            <d15>0000</d15> 
            <d16>0000</d16> 
            <d17>0000</d17> 
            <d18>0000</d18> 
            <d19>0000</d19> 
            <d20>0000</d20> 
            <d21>0000</d21> 
            <d22>0000</d22> 
            <d23>0000</d23> 
            <d24>0000</d24> 
            <d25>0000</d25> 
            <d26>0000</d26> 
            <d27>0000</d27> 
            <d28>0000</d28> 
            <d29>0000</d29> 
            <d30>0000</d30> 
            <d31>0000</d31> 
        </days>
        <mths>
            <m01>0000</m01>     Total kWh used per month
            <m02>0000</m02> 
            <m03>0000</m03> 
            <m04>0000</m04> 
            <m05>0000</m05> 
            <m06>0000</m06> 
            <m07>0000</m07> 
            <m08>0000</m08> 
            <m09>0000</m09> 
            <m10>0000</m10> 
            <m11>0000</m11> 
            <m12>0000</m12> 
        </mths>
        <yrs>
            <y1>0000000</y1>    Total kWh used per year
            <y2>0000000</y2> 
            <y3>0000000</y3> 
            <y4>0000000</y4> 
        </yrs>
    </hist>
 </msg>

=head2 CC128 format

For full definition, see L<http://www.currentcost.com/xx128/xml.html>

 <msg>                           start of message
   <src>CC128-v0.11</src>        source and software version
   <dsb>00089</dsb>              days since birth, ie days run
   <time>13:02:39</time>         24 hour clock time as displayed
   <tmpr>18.7</tmpr>             temperature as displayed
   <sensor>1</sensor>            Appliance Number as displayed
   <id>01234</id>                radio ID received from the sensor
   <type>1</type>                sensor Type, "1" = electricity
   <ch1>                         sensor channel
      <watts>00345</watts>       data and units
   </ch1>
   <ch2>
      <watts>02151</watts>
   </ch2>
   <ch3>
      <watts>00000</watts>
   </ch3>
 </msg>                           end of message
 
=cut

if ( defined $ARGV[0] and $ARGV[0] eq 'config' ) {
    if ($ret) {
        print $ret;
        exit 1;
    }

    # Start the daemon
    if ($MUNIN_DEBUG) {
        print STDERR "# Will run collection daemon locally for 30 seconds...\n";
        run_daemon();
    }
    else {
        my $daemon = Proc::Daemon->new (
            work_dir => $Munin::Plugin::pluginstatedir,
            pid_file => $daemon_pidfile);
        if ( $daemon->Status == 0 ) {
            print STDERR "# Launching Daemon...\n";
            my $ChildPID = $daemon->Init;
            unless ($ChildPID){
                run_daemon();
            }
        }
    }
    print STDERR "# Daemon running\n";

# Open the config spoolfile. That'll tell us what sensors/channels are available
    open( my $spoolfile, '<', $config_spoolfile )
      || die "Can't open spoolfile ($config_spoolfile): $!";
    flock( $spoolfile, LOCK_EX ) or die "Can't lock spoolfile: $!";
    seek( $spoolfile, 0, SEEK_SET ) or die "Can't seek in spoolfile: $!";

    my $confighash = JSON->new->utf8->decode(
        do { local $/ = <$spoolfile> }
    );
    flock( $spoolfile, LOCK_UN ) or die "Can't unlock spoolfile: $!";
    close($spoolfile);

    for my $sensor ( keys %$confighash ) {
        my $sensordata = $confighash->{$sensor};

        if ( $sensor == 0 ) {

            # Output the Root graph (being sensor 0)
            print <<EOF;
multigraph currentcost
graph_title CurrentCost Consumption
graph_args --base 1000 -l 0
graph_vlabel $sensordata->{1}
graph_category currentcost
graph_info This graph shows the 'whole house' data.
graph_total Total
update_rate $tick_rate
graph_data_size custom 1d, 10s for 1w, 1m for 1t, 5m for 1y
EOF
            foreach my $channel ( keys %$sensordata ) {
                my $fieldname = "ch" . $channel;
                print <<EOF;
$fieldname.label Channel $channel
$fieldname.type GAUGE
$fieldname.min 0
$fieldname.draw AREA
${fieldname}_t.label Channel $channel Trend
${fieldname}_t.type GAUGE
${fieldname}_t.min 0
${fieldname}_t.draw LINE2
EOF
                if ($nightrate) {
                    print <<EOF;
${fieldname}_n.label Channel $channel Night
${fieldname}_n.type GAUGE
${fieldname}_n.min 0
${fieldname}_t.cdef ${fieldname}_n,UN,${fieldname},${fieldname},IF,3600,TRENDNAN
EOF
                }
                else {
                    print "${fieldname}_t.cdef ${fieldname},3600,TRENDNAN\n";
                }
            }

            # Output the Root cumulative graph
            print <<EOF;
multigraph currentcost_cumulative
graph_title CurrentCost Total Usage
graph_args --base 1000 -l 0
graph_vlabel $sensordata->{1} * hours
graph_category currentcost
EOF
            print "graph_order ";
            my $confstr = '';
            foreach my $channel ( sort keys %$sensordata ) {
                my $fieldname = "ch" . $channel;
                print "${fieldname}=currentcost.$fieldname ${fieldname}_d ";
                $confstr .= <<EOF;
${fieldname}.update no
${fieldname}.label Channel $channel
${fieldname}.type GAUGE
${fieldname}.min 0
${fieldname}.cdef PREV,${fieldname},12,/,ADDNAN
${fieldname}_d.label Channel $channel Daily
${fieldname}_d.type GAUGE
${fieldname}_d.min 0
EOF
            }
            print "\n$confstr";
            print <<EOF;
fudge.label (fudge)
fudge.type GAUGE
fudge.graph yes
fudge.draw LINE0
EOF

            # Output the root cost graph
            print <<EOF;
multigraph currentcost_cost
graph_title CurrentCost Estimated Cost
graph_args --base 1000 -l 0
graph_vlabel ${currency}
graph_category currentcost
graph_total Total
EOF
            foreach my $channel ( keys %$sensordata ) {
                my $fieldname = "ch" . $channel;
                print <<EOF;
$fieldname.label Channel $channel
$fieldname.type GAUGE
$fieldname.min 0
EOF
            }

        }
        else {

            # Output a subordinate graph (being an appliance)
            print <<EOF;
multigraph currentcost.appliance$sensor
graph_title CurrentCost Consumption (Appliance $sensor)
graph_args --base 1000 -l 0
graph_vlabel $sensordata->{1}
graph_category currentcost
graph_info This graph shows the data for Appliance $sensor
graph_total Total
EOF
            foreach my $channel ( keys %$sensordata ) {
                my $fieldname = "ch" . $channel;
                print <<EOF;
$fieldname.label Channel $channel
$fieldname.type GAUGE
$fieldname.min 0
EOF
                if ($nightrate) {
                    print <<EOF;
${fieldname}_n.label Channel $channel Night
${fieldname}_n.type GAUGE
${fieldname}_n.min 0
EOF
                }
            }

            # Output the subordinate cumulative graph
            print <<EOF;
multigraph currentcost_cumulative.appliance$sensor
graph_title CurrentCost Total Usage (Appliance $sensor)
graph_args --base 1000 -l 0
graph_vlabel $sensordata->{1} * hours
graph_category currentcost
EOF
            print "graph_order ";
            my $confstr = '';
            foreach my $channel ( sort keys %$sensordata ) {
                my $fieldname = "ch" . $channel;
                print "$fieldname=currentcost.$fieldname ";
                $confstr .= <<EOF;
$fieldname.label Channel $channel
$fieldname.type GAUGE
$fieldname.min 0
$fieldname.cdef PREV,$fieldname,12,/,ADDNAN
EOF
            }
            print "\n$confstr";

            # Output the subordinate Cost graph
            print <<EOF;
multigraph currentcost_cost.appliance$sensor
graph CurrentCost Estimated Cost (Appliance $sensor)
graph_args --base 1000 -l 0
graph_vlabel ${currency}
graph_category currentcost
graph_total Total
EOF
            foreach my $channel ( keys %$sensordata ) {
                my $fieldname = "ch" . $channel;
                print <<EOF;
$fieldname.label Channel $channel
$fieldname.type GAUGE
$fieldname.min 0
EOF
            }
        }
    }
    exit 0;
}

# Output the value data
open( my $spoolfile, '<', $config_spoolfile )
  || die "Can't open spoolfile ($config_spoolfile): $!";
flock( $spoolfile, LOCK_EX ) or die "Can't lock spoolfile: $!";
seek( $spoolfile, 0, SEEK_SET ) or die "Can't seek in spoolfile: $!";

my $confighash = JSON->new->utf8->decode(
    do { local $/ = <$spoolfile> }
);
flock( $spoolfile, LOCK_UN ) or die "Can't unlock spoolfile: $!";
close($spoolfile);

open( $spoolfile, '+<', $value_spoolfile )
  || die "Can't open spoolfile ($value_spoolfile): $!";
flock( $spoolfile, LOCK_EX ) or die "Can't lock spoolfile: $!";
seek( $spoolfile, 0, SEEK_SET ) or die "Can't seek in spoolfile: $!";

my @valuearr;
while (<$spoolfile>) {
    push @valuearr, JSON->new->utf8->decode($_);
}

# Make sure to remove the old data from the spool file
truncate( $spoolfile, 0 );

flock( $spoolfile, LOCK_UN ) or die "Can't unlock spoolfile: $!";
close($spoolfile);

# Finally, read (and update) the cumulative spool
my $cumulativehash;
if ( -e $cumulative_spoolfile ) {
    open( $spoolfile, '<', $cumulative_spoolfile )
      || die "Can't open spoolfile ($cumulative_spoolfile): $!";
    $cumulativehash = JSON->new->utf8->decode(
        do { local $/ = <$spoolfile> }
    );
    close($spoolfile);
}
for my $datum ( sort { $a->{timestamp} <=> $b->{timestamp} } @valuearr ) {
    my $lasttime = 0;
    if ( exists( $cumulativehash->{lasttime} ) ) {
        $lasttime = $cumulativehash->{lasttime};
    }
    else {
        $lasttime = $datum->{timestamp} - $tick_rate;
    }

    # How much of an hour is the measured period?
    my $divisor = 3600 / ( $datum->{timestamp} - $lasttime );

    my @nowtime  = localtime( $datum->{timestamp} );
    my @thentime = localtime($lasttime);

    my %is_new = (
        daily   => ( $nowtime[3] != $thentime[3] ) ? 1 : 0,
        monthly => ( $nowtime[4] != $thentime[4] ) ? 1 : 0,
        yearly  => ( $nowtime[5] != $thentime[5] ) ? 1 : 0,
    );
    $is_new{ndaily}   = $is_new{daily};
    $is_new{nmonthly} = $is_new{monthly};
    $is_new{nyearly}  = $is_new{yearly};

    for my $item ( keys %$datum ) {
        next unless $item =~ /^\d+$/;
        for my $period (qw(daily monthly yearly)) {
            $period = "n$period" if is_night_rate( $datum->{timestamp} );
            if ( $is_new{$period} ) {
                print STDERR
                  "# Start of a new $period period. Resetting counter\n"
                  if $MUNIN_DEBUG;
                $cumulativehash->{ $datum->{sensor} }->{$item}->{$period} =
                  $datum->{$item}->{value} / $divisor;
            }
            else {
                $cumulativehash->{ $datum->{sensor} }->{$item}->{$period} +=
                  $datum->{$item}->{value} / $divisor;
            }

            # Also copy the new cumulative value back into the valuearr
            $datum->{$item}->{$period} =
              $cumulativehash->{ $datum->{sensor} }->{$item}->{$period};
        }
    }
}

for my $sensor ( keys %$confighash ) {
    my $sensordata = $confighash->{$sensor};

    if ( $sensor == 0 ) {

        # Output the Root graph (being sensor 0)
        print "multigraph currentcost\n";
    }
    else {
        print "multigraph currentcost.appliance$sensor\n";
    }

    foreach my $channel ( keys %$sensordata ) {
        my $fieldname = "ch$channel";

        foreach my $datum (@valuearr) {
            my $value     = $datum->{$channel}->{value};
            my $timestamp = $datum->{timestamp};
            if ( is_night_rate($timestamp) ) {
                print "${fieldname}_n.value $timestamp:$value\n";
                print "${fieldname}.value $timestamp:0\n";
            }
            else {
                print "${fieldname}.value $timestamp:$value\n";
                print "${fieldname}_n.value $timestamp:0\n";
            }
        }
    }
    if ( $sensor == 0 ) {

        # Output the Root graph (being sensor 0)
        print "multigraph currentcost_cumulative\n";
    }
    else {
        print "multigraph currentcost_cumulative.appliance$sensor\n";
    }
    foreach my $channel ( keys %$sensordata ) {
        my $fieldname = "ch$channel";

        foreach my $datum (@valuearr) {
            my $value     = $datum->{$channel}->{daily};
            my $timestamp = $datum->{timestamp};
            $value += $datum->{$channel}->{ndaily}
              if defined $datum->{$channel}->{ndaily};
            print "${fieldname}_d.value $timestamp:$value\n";
        }
    }
    my @now = localtime(time);
    if ( $now[3] == 1 and $now[2] == 0 and $now[1] <= 5 ) {

        # First reading of month, reset.
        print "fudge.value 0\n";
    }
    else {
        print "fudge.value 1\n";
    }

    if ( $sensor == 0 ) {

        # Output the Root Cost graph (being sensor 0)
        print "multigraph currentcost_cost\n";
    }
    else {
        print "multigraph currentcost_cost.appliance$sensor\n";
    }
    foreach my $channel ( keys %$sensordata ) {
        my $fieldname = "ch" . $channel;

        my $extinfo = "";
        foreach my $datum (@valuearr) {
            my $timestamp = $datum->{timestamp};

            my $kWh      = $datum->{$channel}->{monthly} / 1000;
            my $nightkWh = $datum->{$channel}->{nmonthly} / 1000
              if defined $datum->{$channel}->{nmonthly};
            my $cost = $standingcharge;
            if ( $nightrate and defined $nightkWh ) {
                $cost = $nightkWh * $nightrate;
            }
            if ( $kWh <= $rate1qty ) {
                $cost += $kWh * $rate1;
            }
            else {
                $cost +=
                  ( ( $kWh - $rate1qty ) * $rate2 ) + ( $rate1qty * $rate1 );
            }
            $cost = $cost / 100;    # Convert pence/cents into pounds/euros
            print "$fieldname.value $timestamp:$cost\n";
            $extinfo = sprintf( "Usage so far this month is %.3f kWh.", $kWh );
            $extinfo .= sprintf( " Night usage so far this month is %.3f kWh.",
                $nightkWh )
              if defined $nightkWh;
        }
        print "$fieldname.extinfo $extinfo\n";
    }
}
exit 0;
